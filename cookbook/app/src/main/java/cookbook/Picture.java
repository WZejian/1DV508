package cookbook;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Blob;
import java.sql.ResultSet;

import javax.imageio.ImageIO;

/**
 * READ ME!!
 * This Class handles pictures, the methods should be enough for a majority of use cases.
 * There shouldn't really be a need to create an picture object, as all imaes are either stored
 * as paths or ids from the DB.
 * If you need a image that is already fetched to local, use the path that is returned by these
 * methods. If you need to store a pointer to a image in DB, store the image ID, then fetch the 
 * image when you need to display it.
 * Upload an local image with imgUpload(path), this returns image ID from DB.
 * Fetch(download) using imgFetch(id), This returns a path to the image.
 * This class can be modified to use java's path class as image path returns, tell me if this
 * is needed. This class defaults to do outputs to the ./tmp folder, which can be cleared at
 * the end of program execution using clearTmp().
 * clearTmp() looks for and deletes all files in ./tmp, and it does not delete any other
 * subdirectories found under ./tmp.
 * - Yan
 */
public class Picture {

  /**
   * Uploads image to DB. Images are always cropped the largest possible square
   * obtainable, and then changed to 500*500 resolution. The square is cropped
   * from the exact center of the image. 
   * Supported formats: .bmp .jpeg .wbmp .gif .png .jpg
   *
   * @param imgPath Path of image to read and upload to DB
   * @return ID auto-generated by DB. Negative return indicates unsuccessful upload
   */
  public static int imgUpload(Path imgPath) {
    final String insertQuery = "INSERT INTO images (image_blob) VALUES (?);";
    final String idQuery = "SELECT LAST_INSERT_ID();";
    int idReturn = -1;
    try {
      DbConnector.runUpdateQuery(insertQuery, Picture.readToBlob(imgPath));
    } catch (Exception e1) {
      e1.printStackTrace();
      return -2;
    }
    try {
      ResultSet rs = DbConnector.runQuery(idQuery);
      while (rs.next()) {
        idReturn = rs.getInt("LAST_INSERT_ID()");
      }
    } catch (Exception e2) {
      return -3;
    }
    return idReturn;
  }

  /**
   * Downloads image from DB specified by image ID.
   *
   * @param id ID of image
   * @return Path of image to display, will return a placeholder if error occurs.
   */
  public static Path imgFetch(int id) {
    final String selectQuery = "SELECT image_blob FROM cookbook.images WHERE image_id=?;";
    final Path placeholderPath = Paths.get("tmp/safeFolder/placeholder.jpeg");
    String imgPathstr = "tmp/" + Integer.toString(id) + ".jpeg";
    Path imgPath = Paths.get(imgPathstr).toAbsolutePath();
    ResultSet rs = DbConnector.runQuery(selectQuery, id);
    Blob imgBlob = null;

    try {
      while (rs.next()) {
        imgBlob = rs.getBlob("image_blob");
      }
    } catch (Exception e) {
      return placeholderPath;
    }

    if (imgBlob != null) {
      try {
        blobToImage(imgBlob, id);
        return imgPath;
      } catch (Exception e) {
        return placeholderPath;
      }
    } else {
      return placeholderPath;
    }
  }

  /**
   * Downloads image from DB specified by image ID. FileInputStream Variant.
   *
   * @param id ID of image
   * @return Path of image to display, will return a placeholder if error occurs.
   */
  public static FileInputStream imgFetchFileInputStream(int id) {
    final String selectQuery = "SELECT image_blob FROM cookbook.images WHERE image_id=?;";
    final Path placeholderPath = Paths.get("tmp/safeFolder/placeholder.jpeg");
    FileInputStream placeholderInS = null;
    try {
      placeholderInS = new FileInputStream(placeholderPath.toString());
    } catch (Exception e) {
      assert true; //this is 'do nothing', assert true is used to make this searchable
      //this should never be executed, as placeholder path should always work
    }
    String imgPathstr = "tmp/" + Integer.toString(id) + ".jpeg";
    ResultSet rs = DbConnector.runQuery(selectQuery, id);
    Blob imgBlob = null;

    try {
      while (rs.next()) {
        imgBlob = rs.getBlob("image_blob");
      }
    } catch (Exception e) {
      return placeholderInS;
    }

    if (imgBlob != null) {
      try {
        blobToImage(imgBlob, id);
        return new FileInputStream(imgPathstr);
      } catch (Exception e) {
        return placeholderInS;
      }
    } else {
      return placeholderInS;
    }
  }

  /**
   * Clears the tmp folder of files, spares any subdirectories.
   */
  public static void clearTmp() {
    for (File file: (new File("./tmp")).listFiles()) {
      if (!file.isDirectory()) {
        file.delete();
      }
    }
  }

  /**
   * Reads an image into a byte array.
   * Images are always converted jpegs of 500*500.
   * Only the middle square of each image is used.
   *
   * @param inPath Path of image
   * @return Byte array representation of the image
   * @throws IOException IO errors thrown by things within
   */
  protected static Blob readToBlob(Path inPath) throws IOException {
    final String tmpPath = Paths.get("tmp") + "/tmp.jpg"; // Path used in format conversion
    FileInputStream inputStream = new FileInputStream(inPath.toString()); // Original file reader

    //read, crop, resize, convert
    BufferedImage initialImg = ImageIO.read(inputStream);// Read original file
    int initHeight = initialImg.getHeight();
    int initWidth = initialImg.getWidth();
    int subOriginx = 0; //cropped image's origin of crop, lower left corner
    int subOriginy = 0;
    int cropSize = 300; //Overridden later anyway
    if (initHeight < initWidth) { //'landscape' orientation rectangle
      cropSize = initHeight;
      subOriginx = Integer.valueOf((initWidth - initHeight) / 2);
    } else { //'vertical' orientation
      cropSize = initWidth;
      subOriginy = Integer.valueOf((initHeight - initWidth) / 2);
    }
    BufferedImage cropImg = initialImg.getSubimage(subOriginx, subOriginy, cropSize, cropSize);
    int resizexy = 500; //size of final picture
    BufferedImage resizeImg = new BufferedImage(resizexy, resizexy, cropImg.getType());
    Graphics2D g2d = resizeImg.createGraphics();  //Don't ask me how this works
    g2d.drawImage(cropImg, 0, 0, resizexy, resizexy, null);
    g2d.dispose();
    FileOutputStream outStream = new FileOutputStream(tmpPath); // Temp file writer
    ImageIO.write(resizeImg, "jpeg", outStream); // Write tmp file with format conversion to jpeg

    //read and delete tmp
    File tmpFile = new File(tmpPath); // Object created mainly to use the .length and .delete method
    byte[] binary = new byte[(int) tmpFile.length()];
    FileInputStream tmpInStream = new FileInputStream(tmpFile); // Temp file reader

    //cleaning up
    tmpInStream.read(binary); // Read temp file into binary
    tmpInStream.close();
    inputStream.close();
    outStream.close();
    tmpFile.delete(); // Delete temp file

    // Blob conversion
    Blob blobOut = null;
    try {
      blobOut = new javax.sql.rowset.serial.SerialBlob(binary);
    } catch (Exception e) {
      ;
    }
    return blobOut;
  }

  /**
   * Converts a byte array back to image.
   * All images are jpeg format.
   *
   * @param imgName Name of image, DO NOT INCLUDE ".jpeg"
   * @throws IOException IO errors.
   */
  private static void blobToImage(Blob blobIn, int imgId) throws IOException {
    String outName = "tmp/" + String.valueOf(imgId) + ".jpeg";
    Path outPath = Paths.get(outName).toAbsolutePath();

    // Conversion from blob to byte[]
    byte[] binary = null;
    try {
      int blobLength = (int) blobIn.length();
      binary = blobIn.getBytes(1, blobLength);
    } catch (Exception e) {
      ;
      return;
    }

    // ImageIO reads from binary supplied by binaryIn, then this buffered image is written
    ByteArrayInputStream binaryIn = new ByteArrayInputStream(binary);
    BufferedImage newImage = ImageIO.read(binaryIn);
    ImageIO.write(newImage, "jpeg", new File(outPath.toString()));
    binaryIn.close();
  }
}
